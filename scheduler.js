// Generated by CoffeeScript 1.4.0
(function() {

  define("scheduler", ['algorithm'], function(Algoritm) {
    var Scheduler;
    return Scheduler = (function() {

      Scheduler.prototype.mapToKey = function(m) {
        return JSON.stringify(_.map(_.keys(m).sort(), function(x) {
          return [x, m[x]];
        }));
      };

      function Scheduler(allPossibilities) {
        this.allPossibilities = allPossibilities;
        this.stats = {};
        this.counter = 0;
        this.numEvents = 0;
        this.squaredError = 0.0;
        this.probCache = {};
        this.subKeys = {};
      }

      Scheduler.prototype.benchmark = function() {
        return Math.sqrt(this.squaredError / this.numEvents);
      };

      Scheduler.prototype.getOrNewAlgoritm = function(features) {
        var algorithm, key;
        key = this.mapToKey(features);
        if (!this.stats[key]) {
          this.stats[key] = new Algoritm();
        }
        return algorithm = this.stats[key];
      };

      Scheduler.prototype.userEvent = function(event) {
        var algorithm, currentFeatures, currentGoodValue, currentKey, features, featuresWithSize, goodValue, maxs, newKey, prob, s, smallerFeature, smallerFeatures, strength, strength2, value2, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _results;
        this.counter += 1;
        features = event.features;
        if (!features) {
          return;
        }
        prob = this.probability(features, event.timestamp);
        goodValue = (_ref = event.good) != null ? _ref : {
          1: 0
        };
        this.squaredError += (goodValue - prob) * (goodValue - prob);
        this.numEvents += 1;
        this.probCache = {};
        s = maxs = _.keys(features).length;
        featuresWithSize = {};
        featuresWithSize[s] = [[features, this.mapToKey(features), goodValue, 1]];
        _results = [];
        while (s > 0) {
          smallerFeatures = {};
          _ref1 = featuresWithSize[s];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            _ref2 = _ref1[_i], currentFeatures = _ref2[0], currentKey = _ref2[1], currentGoodValue = _ref2[2];
            algorithm = this.getOrNewAlgoritm(currentFeatures);
            strength = Math.pow(s / maxs + 0.000001, 0.6);
            strength2 = Math.pow(s / maxs + 0.000001, -0.5);
            value2 = (goodValue - 0.5) * strength2 + 0.5;
            algorithm.update(value2, this.counter, event.timestamp, strength);
            _ref3 = this.getSubKeys(currentFeatures, currentKey);
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              _ref4 = _ref3[_j], smallerFeature = _ref4[0], newKey = _ref4[1];
              if (!smallerFeatures[newKey]) {
                smallerFeatures[newKey] = [smallerFeature, newKey, goodValue, 1];
              } else {
                smallerFeatures[newKey][3] += 1;
                if (currentGoodValue) {
                  smallerFeatures[newKey][2] += 1;
                }
              }
            }
          }
          s -= 1;
          _results.push(featuresWithSize[s] = _.values(smallerFeatures));
        }
        return _results;
      };

      Scheduler.prototype.getSubKeys = function(features, key) {
        var allSubKeyPairs, takeFeature, takenValue, _i, _len, _ref;
        allSubKeyPairs = this.subKeys[key];
        if (!allSubKeyPairs) {
          allSubKeyPairs = [];
          _ref = _.keys(features);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            takeFeature = _ref[_i];
            takenValue = features[takeFeature];
            delete features[takeFeature];
            allSubKeyPairs.push([_.clone(features), this.mapToKey(features)]);
            features[takeFeature] = takenValue;
          }
          this.subKeys[key] = allSubKeyPairs;
        }
        return allSubKeyPairs;
      };

      Scheduler.prototype.probabilityWithConfidence = function(features, timestamp, key) {
        var conf, count, n, origN, prob, probWithConf, product, r, r2, r3, subKeyPair, sum, sum2, sum2p, _i, _len, _ref;
        if (key == null) {
          key = this.mapToKey(features);
        }
        if (this.probCache[key]) {
          return this.probCache[key];
        }
        sum = 0.0;
        sum2 = 0.0;
        sum2p = 0.5;
        product = 1.0;
        n = 0;
        origN = 0;
        r = [0, 0];
        if (this.stats[key]) {
          r = [this.stats[key].predict_at(this.counter + 1, timestamp), this.stats[key].confidence];
          this.probCache[key] = r;
        }
        _ref = this.getSubKeys(features, key);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subKeyPair = _ref[_i];
          probWithConf = this.probabilityWithConfidence(subKeyPair[0], timestamp, subKeyPair[1]);
          prob = probWithConf[0];
          conf = probWithConf[1];
          count = Math.pow(conf, 0.2);
          sum += prob * count;
          n += count;
          origN += 1;
        }
        if (n === 0) {
          r2 = [0, 0];
        } else {
          r2 = [0.9 * sum / n, Math.pow(origN / n, -10) / 2];
        }
        if (r[1] === 0) {
          r3 = r2;
        } else if (r[1] < 1 && r2[1] > 0.9) {
          r3 = [(r2[0] + r[0]) / 2, r[1]];
        } else {
          r3 = r;
        }
        this.probCache[key] = r3;
        return r3;
      };

      Scheduler.prototype.probability = function(features, timestamp, key) {
        return this.probabilityWithConfidence(features, timestamp, key)[0];
      };

      Scheduler.prototype.best = function(timestamp) {
        var best, bestProbability, possibility, probability, _i, _len, _ref;
        best = this.allPossibilities[0];
        bestProbability = this.probability(best, timestamp);
        _ref = this.allPossibilities;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          possibility = _ref[_i];
          probability = this.probability(possibility, timestamp);
          if (probability < 0.8) {
            if (bestProbability > 0.8 || bestProbability < probability) {
              best = possibility;
              bestProbability = probability;
            }
          } else {
            if (probability < bestProbability) {
              best = possibility;
              bestProbability = probability;
            }
          }
        }
        return {
          features: best,
          probability: bestProbability
        };
      };

      return Scheduler;

    })();
  });

}).call(this);
